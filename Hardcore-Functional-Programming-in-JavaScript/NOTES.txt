Functions

-Total (For every input there is a corresponding output)
-Deterministic (always receive the same output for a given input)
-No Observable Side-Effects  (No observable effect besides computing a value)

Advantages of pure functions
-Reliable
-Portable
-Reusable
-Testable
-Composable
-Properties/Contract

----------------------
Currying (instead of taking all arguments at one time ; takes one argument at a time and returns a new function expecting the next argument)

Composition (chaining multiple functions together to create a new function)
-Logging in composition (side effecty but helpful for debuging)
const log = curry((tag, x) => (console.log(tag, x), x));
const shout = compose(exclaim, log('tag log'));

Functors (an object with map method, it can be mapped between objects)

Either Monad (functional approach to Error handling,  it has a map, chain, and a fold method)

fromNullable (utility that takes a value and if is not equal to null, return right functor )
	const fromNullable = (x) => (x != null ? Right(x) : Left());

	const findColor = (name) =>
  	fromNullable({ red: "#ff4444", blue: "#3b5998", yellow: "#fff68f" }[name]);

Task Monad (takes a reject and resolve function, just like a Promise, but flipped)
Lazy Promises (allow us to continue to compose and combine, without running it )
	const {Task} = require('../types')

	const testUser = {id: 2, name: 'user1'}

	const Db = ({
	  find: _id =>
	    Task((rej, res) => res(testUser))
	})

	Db.find(3)
	.fork(console.log, console.log)



